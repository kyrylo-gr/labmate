{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Labmate. The mate that simplifies data management in your lab.","text":"<p>This library facilitates the clear division of data acquisition from analysis. It provides robust tools for efficient data management and includes features to ensure a further use of the saved data.</p>"},{"location":"#install","title":"Install","text":"<p><code>pip install labmate</code></p> <p>More on it can be found inside the installation guide</p>"},{"location":"#usage","title":"Usage","text":"<p>For further insight, please refer to the First Steps guide.</p> <p>For more in-depth information, explore the Advanced Examples.</p> <p>To gain a comprehensive understanding of syntax, visit the User Guide menu on the left.</p>"},{"location":"about/","title":"About","text":"<p>This is about page</p> <p>labmate</p>"},{"location":"acquisition_notebook/","title":"Acquisition notebook","text":"<p><code>Acquisition_notebook</code> package is helping for saving the data of your analysis.</p> <p>see <code>acquisition_and_analysis_notebook.ipynb</code> to see how it works</p>"},{"location":"h5nparray/","title":"H5NpArray","text":"<p>In <code>H5PY</code> <code>np.ndarray</code> can be saved as soon as modified. To do that there exists a class <code>H5NpArray</code>. This class synchronously modifies the np.ndarray and file.</p>"},{"location":"h5nparray/#guideline","title":"Guideline","text":"<ol> <li>Open file in write mode.</li> </ol> <pre><code>from labmate.syncdata import SyncData\nsd = SyncData('tmp_data/test.h5', overwrite=True, save_on_edit=False)\n</code></pre> <ol> <li>Define new item as a h5nparray</li> </ol> <pre><code>shape = (100, 1000)\nsd['test_array'] = sd.h5nparray(np.zeros(shape))\n</code></pre> <p><code>H5NpArray</code> takes the np.array as parameter to initialize the data inside the file.</p> <ol> <li>Modify as normal</li> </ol> <pre><code>for i in range(100):\n    sd['test_array'][i, :] = np.random.random(1000)\n</code></pre> <ol> <li>Check that data was saved</li> </ol> <pre><code>read = SyncData('tmp_data/test.h5')\nread['test_array']\n</code></pre>"},{"location":"h5nparray/#implementation","title":"Implementation","text":"<ul> <li> <p><code>H5NpArray</code> has <code>__should_not_be_converted__=True</code>, which prevents <code>SyncData</code> from converting it to an array and continuous using as a class</p> </li> <li> <p>as soon as you run <code>fd[key]</code> it will run method <code>__init__filepath__</code> to provide the filepath and the key to the class <code>H5NpArray</code></p> </li> </ul>"},{"location":"code/acquisition_notebook_manager/","title":"Acquisition notebook manager.","text":"<p>AcquisitionAnalysisManager.</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager--init","title":"Init","text":"<pre><code>aqm = AcquisitionAnalysisManager(\"tmp_data/\", use_magic=False, save_files=False)\naqm.set_config_file(\"configuration.py\")\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager--acquisition_cell","title":"acquisition_cell:","text":"<pre><code>aqm.acquisition_cell('simple_sine')\n...\naqm.save_acquisition(x=x, y=y)\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager--analysis_cell","title":"analysis_cell:","text":"<pre><code>aqm.analysis_cell()\n...\nplt.plot(aqm.d.x, aqm.d.y)\naqm.save_fig()\n</code></pre> Source code in <code>labmate/acquisition_notebook/acquisition_analysis_manager.py</code> <pre><code>class AcquisitionAnalysisManager(AcquisitionManager):\n    \"\"\"AcquisitionAnalysisManager.\n\n    # Init\n    ```\n    aqm = AcquisitionAnalysisManager(\"tmp_data/\", use_magic=False, save_files=False)\n    aqm.set_config_file(\"configuration.py\")\n    ```\n    # acquisition_cell:\n    ```\n    aqm.acquisition_cell('simple_sine')\n    ...\n    aqm.save_acquisition(x=x, y=y)\n    ```\n\n    # analysis_cell:\n    ```\n    aqm.analysis_cell()\n    ...\n    plt.plot(aqm.d.x, aqm.d.y)\n    aqm.save_fig()\n    ```\n\n    \"\"\"\n\n    _analysis_data: Optional[AnalysisData] = None\n    _analysis_cell_str = None\n    _is_old_data = False\n    _last_fig_name = None\n    _default_config_files: Tuple[str, ...] = ()\n    _acquisition_started = 0\n    _linting_external_vars = None\n    _analysis_cell_prerun_hook: Optional[Tuple[_CallableWithNoArgs, ...]] = None\n    _acquisition_cell_prerun_hook: Optional[Tuple[_CallableWithNoArgs, ...]] = None\n    _connected_widgets: Optional[List[\"display_widget.WidgetProtocol\"]] = None\n\n    def __init__(\n        self,\n        data_directory: Optional[Union[str, Any]] = None,\n        *,\n        config_files: Optional[List[str]] = None,\n        save_files: bool = False,\n        use_magic: bool = False,\n        save_on_edit: bool = True,\n        save_on_edit_analysis: Optional[bool] = None,\n        save_fig_inside_h5: bool = False,\n        shell: Any = True,\n        backend: Optional[Union[\"AcquisitionBackend\", Iterable[\"AcquisitionBackend\"]]] = None,\n    ):\n        \"\"\"\n        AcquisitionAnalysisManager.\n\n        Args:\n            data_directory (Optional[str], optional):\n                Path to data_directory. Should be explicitly set here or as environ parameter.\n            config_files (Optional[List[str]], optional):\n                List of paths to config files. Defaults to empty.\n            save_files (bool, optional):\n                True to additionally save config files and the cells to files. Defaults to False.\n                So all information is saved inside the h5 file.\n            use_magic (bool, optional):\n                True to register the magic cells. Defaults to False.\n            save_on_edit (bool. Defaults to True):\n                True to save data for every change.\n            save_on_edit_analysis (bool. Defaults to same as save_on_edit):\n                save_on_edit parameter for AnalysisManager i.e. data inside analysis_cell\n            shell (InteractiveShell | None, optional. Defaults to True):\n                could be provided or explicitly set to None. Defaults to get_ipython().\n        \"\"\"\n        if shell is False or shell is True:  # behavior by default shell\n            try:\n                from IPython.core.getipython import get_ipython\n\n                self.shell = get_ipython()\n            except ImportError:\n                self.shell = None\n        else:  # if any shell is provided. even None\n            self.shell = shell\n\n        if use_magic:\n            from .acquisition_magic_class import load_ipython_extension  # pyright: ignore[reportMissingImports]  # noqa: I001\n\n            load_ipython_extension(aqm=self, shell=self.shell)\n\n        if save_on_edit_analysis is None:\n            save_on_edit_analysis = save_on_edit\n\n        self._save_on_edit_analysis = save_on_edit_analysis\n        self._save_fig_inside_h5 = save_fig_inside_h5\n\n        self._logger = logger\n        super().__init__(\n            data_directory=str(data_directory),\n            config_files=config_files,\n            save_files=save_files,\n            save_on_edit=save_on_edit,\n            backend=backend,\n        )\n\n    @property\n    def logger(self):\n        return self._logger\n\n    @property\n    def current_acquisition(self):\n        \"\"\"Return current acquisition if it's not an old data analyses.\"\"\"\n        if self._is_old_data:\n            return None\n        return super().current_acquisition\n\n    @property\n    def current_analysis(self):\n        \"\"\"Return the current analysis. Class where you cannot change existed keys.\"\"\"\n        return self._analysis_data\n\n    @property\n    def data(self):\n        \"\"\"Same as current_analysis.\"\"\"\n        if self._analysis_data is None:\n            raise ValueError(\"No data set\")\n        return self._analysis_data\n\n    @property\n    def d(self):  # pylint: disable=invalid-name\n        \"\"\"Shorter alias for data.\"\"\"\n        return self.data\n\n    def save_fig_only(\n        self,\n        fig: Optional[\"FigureProtocol\"] = None,\n        name: Optional[Union[str, int]] = None,\n        extensions: Optional[str] = None,\n        **kwds,\n    ) -&gt; \"AcquisitionAnalysisManager\":\n        \"\"\"Save the figure as a file.\n\n        Args:\n            fig (Figure, optional): Figure that should be saved. Figure could be any class with\n             function save_fig implemented. By default gets plt.gcf().\n            name (str, optional): Name of the fig. It's a suffix that will be added to the filename.\n                Defaults to None.\n            extensions(str, optional): Extensions of the file. Defaults to `pdf`.\n            tight_layout(bool, optional): True to call fig.tight_layout(). Defaults to True.\n\n        Raises:\n            ValueError: if analysis_data is not loaded\n\n        Return:\n            self\n        \"\"\"\n        self.data.save_fig(fig=fig, name=name, extensions=extensions, **kwds)\n        return self\n\n    def save_analysis_cell(\n        self,\n        name: Optional[Union[str, int]] = None,\n        cell: Optional[Union[str, Literal[\"none\"]]] = None,\n    ) -&gt; \"AcquisitionAnalysisManager\":\n        if name is None:\n            name = self.data.figure_last_name\n\n        if name is not None:\n            name = str(name)\n\n        cell = cell or self._analysis_cell_str\n\n        self.data.save_analysis_cell(code=cell, code_name=name)\n\n        return self\n\n    def save_fig(\n        self,\n        fig_or_name: Optional[Union[\"FigureProtocol\", str, int]] = None,\n        /,\n        *,\n        fig: Optional[\"FigureProtocol\"] = None,\n        name: Optional[Union[str, int]] = None,\n        cell: Optional[str] = None,\n        **kwds,\n    ) -&gt; \"AcquisitionAnalysisManager\":\n        if fig_or_name is not None:\n            if isinstance(fig_or_name, (str, int)):\n                name = name or fig_or_name\n            else:\n                fig = fig or fig_or_name\n        self.save_fig_only(fig=fig, name=name, **kwds)\n        self.save_analysis_cell(name=name, cell=cell)\n\n        if self.current_acquisition is not None:\n            self._schedule_backend_save(self.current_acquisition)\n\n        if self._connected_widgets:\n            display_widget.display_widgets(\n                self._connected_widgets,\n                aqm=self,\n                fig=fig,\n            )\n        return self\n\n    def __setitem__(self, __key: str, __value: Any) -&gt; None:\n        if self._analysis_data is not None:\n            raise ValueError(\n                \"This is the way to save acquisition data. But analysis data was loaded. \"\n                \"So you possibly run it outside of acquisition_cell\"\n            )\n        acq_data = self.current_acquisition\n        if acq_data is None:\n            raise ValueError(\n                \"Cannot save data to acquisition as current acquisition is None.\"\n                \"Possibly because you have never run `acquisition_cell(..)` or it's an old data\"\n            )\n        acq_data[__key] = __value  # pylint: disable=E1137\n\n    def save_acquisition(\n        self, update_: bool = True, /, file_suffix: Optional[str] = None, **kwds\n    ) -&gt; \"AcquisitionAnalysisManager\":\n        acquisition_finished = time.time()\n        if not self._once_saved:\n            additional_info: Dict[str, Any] = {\n                \"acquisition_duration\": acquisition_finished - self._acquisition_started,\n                \"logs\": self.logger.getvalue(),\n                \"prints\": self.logger.get_stdout(),\n            }\n            if self._default_config_files:\n                additional_info.update({\"default_config_files\": self._default_config_files})\n            kwds.update({\"info\": additional_info})\n\n        super().save_acquisition(update_, file_suffix=file_suffix, **kwds)\n        self._load_analysis_data()\n        return self\n\n    def _load_analysis_data(self, filepath: Optional[str] = None):\n        filepath = filepath or str(self.current_filepath)\n\n        self._analysis_data = self.load_file(filepath)\n\n        if self._save_on_edit_analysis is False:\n            self._analysis_data.save()\n\n        return self._analysis_data\n\n    def load_file(self, filename) -&gt; \"AnalysisData\":\n        \"\"\"\n        Loads an analysis data file.\n\n        Args:\n            filename (str): The name of the file to load.\n\n        Returns:\n            AnalysisData: An instance of AnalysisData containing the loaded data.\n\n        Raises:\n            ValueError: If the file cannot be found.\n\n        Notes:\n            - The method checks if the file exists with a \".h5\" extension.\n            - If the data does not have a \"useful\" attribute set to True, it updates this attribute.\n            - If default configuration files are provided, they are set in the loaded data.\n        \"\"\"\n        filename = self._get_full_filename(filename)\n        if not os.path.exists(filename if filename.endswith(\".h5\") else filename + \".h5\"):  # noqa: PTH110\n            raise ValueError(f\"File {filename} cannot be found\")\n\n        data = AnalysisData(\n            filepath=filename,\n            save_files=self._save_files,\n            save_on_edit=self._save_on_edit_analysis,\n            save_fig_inside_h5=self._save_fig_inside_h5,\n            open_on_init=False,\n        )\n\n        if not data.get(\"useful\", True):\n            data.unlock_data(\"useful\").update(**{\"useful\": True}).lock_data(\"useful\")\n\n        if self._default_config_files:\n            data.set_default_config_files(self._default_config_files)\n\n        return data\n\n    def acquisition_cell(\n        self,\n        name: str,\n        cell: Optional[str] = None,\n        prerun: Optional[Union[_CallableWithNoArgs, List[_CallableWithNoArgs]]] = None,\n        save_on_edit: Optional[bool] = None,\n        step: int = 1,\n    ) -&gt; \"AcquisitionAnalysisManager\":\n        self._analysis_cell_str = None\n        self._analysis_data = None\n        self._is_old_data = False\n        self._acquisition_started = time.time()\n\n        cell = cell or get_current_cell(self.shell)\n        if step == 1:\n            self.logger.reset()\n            self.new_acquisition(name=name, cell=cell, save_on_edit=save_on_edit)\n        elif self._current_acquisition is None:\n            raise ValueError(\"Acquisition should start from step 1\")\n        elif self._current_acquisition.current_step == step:\n            raise ValueError(\n                \"This step was already run. Please run the next step or restart from step 1\"\n            )\n        else:\n            if self._current_acquisition.experiment_name != name:\n                raise ValueError(\n                    f\"Current acquisition ('{self.current_experiment_name}') \"\n                    f\"isn't the one expected ('{name}') for this acquisition. \"\n                    f\"Possible solutions: run acquisition '{name}' with step 1; \"\n                    f\"or change current acquisition name to '{self.current_experiment_name}'\"\n                )\n            self._current_acquisition.current_step = step\n            self._current_acquisition.set_cell(cell, step=step)\n            self._current_acquisition.save_cell(cell, suffix=str(step))\n            configs_modified = self._get_configs_last_modified()\n            if configs_modified != self._configs_last_modified:\n                raise ValueError(\n                    \"Config files were modified since the previous acquisition step. \"\n                    \"Please rerun the acquisition from the first step.\"\n                )\n            self.logger.stdout_flush()\n\n        self.logger.info(  # pylint: disable=W1203\n            f\"{step}:{self.current_filepath.basename}\"\n        )\n\n        if step == 1:\n            utils.run_functions(self._acquisition_cell_prerun_hook)\n\n        utils.run_functions(prerun)\n\n        return self\n\n    def analysis_cell(\n        self,\n        filename: Optional[Union[str, \"Path\"]] = None,\n        *,\n        acquisition_name=None,\n        cell: Optional[str] = None,\n        filepath: Optional[Union[str, \"Path\"]] = None,\n        prerun: Optional[Union[_CallableWithNoArgs, List[_CallableWithNoArgs]]] = None,\n    ) -&gt; \"AcquisitionAnalysisManager\":\n        # self.shell.get_local_scope(1)['result'].info.raw_cell  # type: ignore\n\n        self._analysis_cell_str = cell or get_current_cell(self.shell)\n        if filename or filepath:  # getting old data\n            self._is_old_data = True\n            if self.shell is not None:\n                from labmate.display.html_output import display_warning\n\n                display_warning(\"Old data analysis\")\n\n            filename = str(filepath or self._get_full_filename(filename))  # type: ignore\n            filename = (filename.rsplit(\".h5\", 1)[0]) if filename.endswith(\".h5\") else filename\n\n        else:\n            self._is_old_data = False\n            if acquisition_name is not None:\n                import re\n\n                if (\n                    len(acquisition_name) == 0\n                    or (\n                        acquisition_name[0] != r\"^\"\n                        and acquisition_name != self.current_experiment_name\n                    )\n                    or (\n                        acquisition_name[0] == r\"^\"\n                        and re.match(acquisition_name, self.current_experiment_name) is None\n                    )\n                ):\n                    raise ValueError(\n                        f\"Current acquisition ('{self.current_experiment_name}') \"\n                        f\"isn't the one expected ('{acquisition_name}') for this analysis\"\n                    )\n\n            filename = str(self.current_filepath)  # without h5\n        self.logger.info(os.path.basename(filename))  # noqa: PTH119\n\n        if (\n            (not self._is_old_data)\n            and (self.shell is not None)\n            and (\n                \"acquisition_cell(\" in self.shell.last_execution_result.info.raw_cell  # type: ignore\n                and not self.shell.last_execution_result.success  # type: ignore\n            )\n        ):\n            raise ChildProcessError(\n                \"Last executed cell was probably an `acquisition_cell` and failed to run. \"\n                \"Check if everything is ok and executive again\"\n            )\n\n        if os.path.exists(filename + \".h5\"):  # noqa: PTH110\n            self._load_analysis_data(filename)\n        else:\n            if self._is_old_data:\n                raise ValueError(f\"Cannot load data from {filename}\")\n            self._analysis_data = None\n\n        if cell is not None:\n            self.save_analysis_cell(cell=cell)\n\n        if (self._analysis_cell_str is not None) and (self._linting_external_vars is not None):\n            from ..acquisition import custom_lint\n            from ..utils import lint\n\n            # _, external_vars = lint.find_variables_from_code(\n            #     self._analysis_cell_str, self._linting_external_vars\n            # )\n            lint_result = lint.find_variables_from_code(\n                self._analysis_cell_str,\n                self._linting_external_vars,\n                run_on_call=custom_lint.on_call_functions,\n            )\n            for var in lint_result.external_vars:\n                self.logger.warning(\"External variable used inside the analysis code: %s\", var)\n            for error in lint_result.errors:\n                self.logger.warning(error)\n\n        utils.run_functions(self._analysis_cell_prerun_hook)\n        utils.run_functions(prerun)\n\n        return self\n\n    def get_analysis_code(self, look_inside: bool = True) -&gt; str:\n        code = self.data.get_analysis_code(update_code=look_inside)\n\n        if self.shell is not None:\n            self.shell.set_next_input(code)  # type: ignore\n        return code\n\n    # def open_analysis_fig(self) -&gt; List[FigureProtocol]:\n    #     return self.data.open_fig()\n\n    def _get_full_filename(self, filename: Union[str, \"Path\"]) -&gt; str:\n        if filename is None:\n            raise ValueError(\"Filename cannot be None\")\n\n        filepath = utils.get_path_from_filename(filename)\n        if isinstance(filepath, tuple):\n            return os.path.join(self.data_directory, *filepath)  # noqa: PTH118\n        return filepath\n\n    def parse_config_file(self, config_file_name: str, /) -&gt; \"ConfigFile\":\n        return self.data.parse_config_file(config_file_name)\n\n    def parse_config(self, config_files: Optional[Tuple[str, ...]] = None) -&gt; \"ConfigFile\":\n        return self.data.parse_config(config_files=config_files)\n\n    @property\n    def cfg(self) -&gt; \"ConfigFile\":\n        return self.data.cfg\n\n    def parse_config_str(\n        self,\n        values: List[str],\n        /,\n        max_length: Optional[int] = None,\n    ) -&gt; str:\n        return self.data.parse_config_str(values, max_length=max_length)\n\n    def linting(\n        self,\n        allowed_variables: Optional[Iterable[str]] = None,\n        init_file: Optional[str] = None,\n    ):\n        from ..utils import lint\n\n        allowed_variables = set() if allowed_variables is None else set(allowed_variables)\n        if init_file is not None:\n            allowed_variables.update(lint.find_variables_from_file(init_file)[0])\n        self._linting_external_vars = allowed_variables\n\n    def set_default_config_files(self, config_files: Union[str, Tuple[str, ...], List[str]], /):\n        self._default_config_files = (\n            (config_files,) if isinstance(config_files, str) else tuple(config_files)\n        )\n        if self._analysis_data:\n            self._analysis_data.set_default_config_files(self._default_config_files)\n\n    def set_analysis_cell_prerun_hook(\n        self,\n        hook: Union[\n            _CallableWithNoArgs,\n            List[_CallableWithNoArgs],\n            Tuple[_CallableWithNoArgs, ...],\n        ],\n    ):\n        self._analysis_cell_prerun_hook = (\n            tuple(hook) if isinstance(hook, (list, tuple)) else (hook,)\n        )\n\n    def set_acquisition_cell_prerun_hook(\n        self,\n        hook: Union[\n            _CallableWithNoArgs,\n            List[_CallableWithNoArgs],\n            Tuple[_CallableWithNoArgs, ...],\n        ],\n    ):\n        self._acquisition_cell_prerun_hook = (\n            tuple(hook) if isinstance(hook, (list, tuple)) else (hook,)\n        )\n\n    def find_param_in_config(self, param: str) -&gt; Optional[Tuple[str, int]]:\n        for file in self._default_config_files:\n            for line_no, line in enumerate(self.d[\"configs\", file].split(\"\\n\")):\n                if line.startswith(param):\n                    return file, line_no + 1\n        return None\n\n    def display_param_link(\n        self,\n        params: Union[str, List[str], List[Tuple[str, str]]],\n        after_text: Optional[str] = None,\n        title: Optional[str] = None,\n    ):\n        if after_text is not None:\n            if not isinstance(params, str):\n                raise ValueError(\n                    \"Cannot use after_text with multiple params. \"\n                    \"Use params=[(param, after_text), ...] instead.\"\n                )\n            return self.display_param_link(params=[(params, after_text)], title=title)\n\n        if isinstance(params, str):\n            params = [params]\n\n        links = \"\" if not title else title + \"&lt;br/&gt;\"\n        for param in params:\n            if not isinstance(param, str):\n                param_text, after_text = param\n            else:\n                param_text, after_text = param, None\n\n            res = self.find_param_in_config(param_text)\n            if res is None:\n                self.logger.warning(\n                    \"Parameter '%s' cannot be found in default config files.\", param\n                )\n                continue\n            file, line_no = res\n            file = self._config_files_names_to_path.get(file, file)\n            link = display.links.create_link(param_text, file, line_no, after_text)\n            links += link + \"&lt;br/&gt;\"\n        return display.display_html(links)\n\n    def display_cfg_link(\n        self,\n        parameters: Dict[str, Any],\n        update_button: bool = False,\n    ):\n        from labmate.display import html_output\n\n        links = []\n        for param, value in parameters.items():\n            param_eq = f\"{param.strip()} = \"\n            res = self.find_param_in_config(param_eq)\n            if res is None:\n                self.logger.warning(\n                    \"Parameter '%s' cannot be found in default config files.\", param\n                )\n                continue\n            file, line_no = res\n            file = self._config_files_names_to_path.get(file, file)\n\n            def update_value(param, value):\n                self.update_config_params_on_disk({param: value})\n\n            buttons = (\n                [display.buttons.create_button(update_value, param, value, name=\"Update\")]\n                if update_button\n                else None\n            )\n\n            link = html_output.create_link_row(\n                link_text=f\"{param} = \",\n                link_url=f\"{file}:{line_no}\",\n                text=str(value),\n                buttons=buttons,  # type: ignore\n            )\n            links.append(link)\n        return display.display_widgets_vertically(links, class_=\"labmate-params\")\n\n    def update_config_params_on_disk(self, params: Dict[str, Any]):\n        # params_per_files = {}\n        # for param, value in params.items():\n        #     res = self.find_param_in_data_config(param)\n        #     if res is None:\n        #         raise ValueError(\n        #             f\"Parameter '{param}' cannot be found in default config files.\"\n        #         )\n        #     file, _ = res\n        #     params_per_files.setdefault(file, {})[param] = value\n\n        for file in self.config_files:\n            file = self._config_files_names_to_path.get(file, file)\n            utils.file_read.update_file_variable(file, params)\n\n        return self\n\n    def connect_default_widget(\n        self,\n        objs: Union[\"display_widget.WidgetProtocol\", List[\"display_widget.WidgetProtocol\"]],\n    ):\n        if not isinstance(objs, (list, tuple)):\n            objs = [objs]\n        if self._connected_widgets is None:\n            self._connected_widgets = []\n        self._connected_widgets.extend(objs)\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.acquisition_tmp_data","title":"acquisition_tmp_data  <code>property</code> <code>writable</code>","text":"<pre><code>acquisition_tmp_data\n</code></pre> <p>Return information about the current acquisition.</p> <p>Returns class attribute or read it from temp.json file if first is not set. Returns:     AcquisitionTmpData(NamedTuple):         experiment_name: current experiment name         time_stamp: time stamp of the current acquisition         configs: dict of configurations files to save         directory: directory where the data is stored</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.current_acquisition","title":"current_acquisition  <code>property</code>","text":"<pre><code>current_acquisition\n</code></pre> <p>Return current acquisition if it's not an old data analyses.</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.current_analysis","title":"current_analysis  <code>property</code>","text":"<pre><code>current_analysis\n</code></pre> <p>Return the current analysis. Class where you cannot change existed keys.</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.d","title":"d  <code>property</code>","text":"<pre><code>d\n</code></pre> <p>Shorter alias for data.</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.data","title":"data  <code>property</code>","text":"<pre><code>data\n</code></pre> <p>Same as current_analysis.</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.data_directory","title":"data_directory  <code>property</code> <code>writable</code>","text":"<pre><code>data_directory\n</code></pre> <p>Return the path to the directory where the data is stored.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the directory where the data is stored.</p>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.__init__","title":"__init__","text":"<pre><code>__init__(data_directory=None, *, config_files=None, save_files=False, use_magic=False, save_on_edit=True, save_on_edit_analysis=None, save_fig_inside_h5=False, shell=True, backend=None)\n</code></pre> <p>AcquisitionAnalysisManager.</p> <p>Parameters:</p> Name Type Description Default <code>data_directory</code> <code>Optional[str]</code> <p>Path to data_directory. Should be explicitly set here or as environ parameter.</p> <code>None</code> <code>config_files</code> <code>Optional[List[str]]</code> <p>List of paths to config files. Defaults to empty.</p> <code>None</code> <code>save_files</code> <code>bool</code> <p>True to additionally save config files and the cells to files. Defaults to False. So all information is saved inside the h5 file.</p> <code>False</code> <code>use_magic</code> <code>bool</code> <p>True to register the magic cells. Defaults to False.</p> <code>False</code> <code>save_on_edit</code> <code>bool. Defaults to True</code> <p>True to save data for every change.</p> <code>True</code> <code>save_on_edit_analysis</code> <code>bool. Defaults to same as save_on_edit</code> <p>save_on_edit parameter for AnalysisManager i.e. data inside analysis_cell</p> <code>None</code> <code>shell</code> <code>InteractiveShell | None, optional. Defaults to True</code> <p>could be provided or explicitly set to None. Defaults to get_ipython().</p> <code>True</code> Source code in <code>labmate/acquisition_notebook/acquisition_analysis_manager.py</code> <pre><code>def __init__(\n    self,\n    data_directory: Optional[Union[str, Any]] = None,\n    *,\n    config_files: Optional[List[str]] = None,\n    save_files: bool = False,\n    use_magic: bool = False,\n    save_on_edit: bool = True,\n    save_on_edit_analysis: Optional[bool] = None,\n    save_fig_inside_h5: bool = False,\n    shell: Any = True,\n    backend: Optional[Union[\"AcquisitionBackend\", Iterable[\"AcquisitionBackend\"]]] = None,\n):\n    \"\"\"\n    AcquisitionAnalysisManager.\n\n    Args:\n        data_directory (Optional[str], optional):\n            Path to data_directory. Should be explicitly set here or as environ parameter.\n        config_files (Optional[List[str]], optional):\n            List of paths to config files. Defaults to empty.\n        save_files (bool, optional):\n            True to additionally save config files and the cells to files. Defaults to False.\n            So all information is saved inside the h5 file.\n        use_magic (bool, optional):\n            True to register the magic cells. Defaults to False.\n        save_on_edit (bool. Defaults to True):\n            True to save data for every change.\n        save_on_edit_analysis (bool. Defaults to same as save_on_edit):\n            save_on_edit parameter for AnalysisManager i.e. data inside analysis_cell\n        shell (InteractiveShell | None, optional. Defaults to True):\n            could be provided or explicitly set to None. Defaults to get_ipython().\n    \"\"\"\n    if shell is False or shell is True:  # behavior by default shell\n        try:\n            from IPython.core.getipython import get_ipython\n\n            self.shell = get_ipython()\n        except ImportError:\n            self.shell = None\n    else:  # if any shell is provided. even None\n        self.shell = shell\n\n    if use_magic:\n        from .acquisition_magic_class import load_ipython_extension  # pyright: ignore[reportMissingImports]  # noqa: I001\n\n        load_ipython_extension(aqm=self, shell=self.shell)\n\n    if save_on_edit_analysis is None:\n        save_on_edit_analysis = save_on_edit\n\n    self._save_on_edit_analysis = save_on_edit_analysis\n    self._save_fig_inside_h5 = save_fig_inside_h5\n\n    self._logger = logger\n    super().__init__(\n        data_directory=str(data_directory),\n        config_files=config_files,\n        save_files=save_files,\n        save_on_edit=save_on_edit,\n        backend=backend,\n    )\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.create_acquisition","title":"create_acquisition","text":"<pre><code>create_acquisition(name=None, cell=None, save_on_edit=None)\n</code></pre> <p>Create a new acquisition with the given experiment name.</p> Source code in <code>labmate/acquisition/acquisition_manager.py</code> <pre><code>def create_acquisition(\n    self,\n    name: Optional[str] = None,\n    cell: Optional[str] = None,\n    save_on_edit: Optional[bool] = None,\n) -&gt; NotebookAcquisitionData:\n    \"\"\"Create a new acquisition with the given experiment name.\"\"\"\n    configs = read_files(self.config_files)\n\n    if self.config_files_eval:\n        configs = append_values_from_modules_to_files(configs, self.config_files_eval)\n\n    if name is None:\n        name = self.current_experiment_name + \"_item\"\n\n    dic = AcquisitionTmpData(\n        experiment_name=name,\n        time_stamp=get_timestamp(),\n        configs=configs,\n        directory=self.data_directory,\n    )\n\n    filepath = self.create_path_from_tmp_data(dic)\n    configs = configs if configs else None\n    save_on_edit = save_on_edit if save_on_edit is not None else self._save_on_edit\n\n    acquisition = NotebookAcquisitionData(\n        filepath=str(filepath),\n        configs=configs,\n        cell=cell or self.cell,\n        overwrite=False,\n        save_on_edit=save_on_edit,\n        save_files=self._save_files,\n    )\n    # TODO: chech if this gives the expected behaviour\n    self._schedule_backend_load(acquisition)\n\n    return acquisition\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.load_file","title":"load_file","text":"<pre><code>load_file(filename)\n</code></pre> <p>Loads an analysis data file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to load.</p> required <p>Returns:</p> Name Type Description <code>AnalysisData</code> <code>AnalysisData</code> <p>An instance of AnalysisData containing the loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be found.</p> Notes <ul> <li>The method checks if the file exists with a \".h5\" extension.</li> <li>If the data does not have a \"useful\" attribute set to True, it updates this attribute.</li> <li>If default configuration files are provided, they are set in the loaded data.</li> </ul> Source code in <code>labmate/acquisition_notebook/acquisition_analysis_manager.py</code> <pre><code>def load_file(self, filename) -&gt; \"AnalysisData\":\n    \"\"\"\n    Loads an analysis data file.\n\n    Args:\n        filename (str): The name of the file to load.\n\n    Returns:\n        AnalysisData: An instance of AnalysisData containing the loaded data.\n\n    Raises:\n        ValueError: If the file cannot be found.\n\n    Notes:\n        - The method checks if the file exists with a \".h5\" extension.\n        - If the data does not have a \"useful\" attribute set to True, it updates this attribute.\n        - If default configuration files are provided, they are set in the loaded data.\n    \"\"\"\n    filename = self._get_full_filename(filename)\n    if not os.path.exists(filename if filename.endswith(\".h5\") else filename + \".h5\"):  # noqa: PTH110\n        raise ValueError(f\"File {filename} cannot be found\")\n\n    data = AnalysisData(\n        filepath=filename,\n        save_files=self._save_files,\n        save_on_edit=self._save_on_edit_analysis,\n        save_fig_inside_h5=self._save_fig_inside_h5,\n        open_on_init=False,\n    )\n\n    if not data.get(\"useful\", True):\n        data.unlock_data(\"useful\").update(**{\"useful\": True}).lock_data(\"useful\")\n\n    if self._default_config_files:\n        data.set_default_config_files(self._default_config_files)\n\n    return data\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.new_acquisition","title":"new_acquisition","text":"<pre><code>new_acquisition(name, cell=None, save_on_edit=None)\n</code></pre> <p>Create a new acquisition with the given experiment name.</p> Source code in <code>labmate/acquisition/acquisition_manager.py</code> <pre><code>def new_acquisition(\n    self, name: str, cell: Optional[str] = None, save_on_edit: Optional[bool] = None\n) -&gt; NotebookAcquisitionData:\n    \"\"\"Create a new acquisition with the given experiment name.\"\"\"\n    self._current_acquisition = None\n    self._once_saved = False\n    self.cell = cell\n    configs = read_files(self.config_files)\n    self._configs_last_modified = self._get_configs_last_modified()\n\n    if self.config_files_eval:\n        configs = append_values_from_modules_to_files(configs, self.config_files_eval)\n\n    dic = AcquisitionTmpData(\n        experiment_name=name,\n        time_stamp=get_timestamp(),\n        configs=configs,\n        directory=self.data_directory,\n    )\n\n    self.acquisition_tmp_data = dic\n\n    self._current_acquisition = self.get_acquisition(replace=True, save_on_edit=save_on_edit)\n\n    return self.current_acquisition\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.save_fig_only","title":"save_fig_only","text":"<pre><code>save_fig_only(fig=None, name=None, extensions=None, **kwds)\n</code></pre> <p>Save the figure as a file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figure that should be saved. Figure could be any class with function save_fig implemented. By default gets plt.gcf().</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the fig. It's a suffix that will be added to the filename. Defaults to None.</p> <code>None</code> <code>extensions</code> <code>str</code> <p>Extensions of the file. Defaults to <code>pdf</code>.</p> <code>None</code> <code>tight_layout</code> <code>bool</code> <p>True to call fig.tight_layout(). Defaults to True.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if analysis_data is not loaded</p> Return <p>self</p> Source code in <code>labmate/acquisition_notebook/acquisition_analysis_manager.py</code> <pre><code>def save_fig_only(\n    self,\n    fig: Optional[\"FigureProtocol\"] = None,\n    name: Optional[Union[str, int]] = None,\n    extensions: Optional[str] = None,\n    **kwds,\n) -&gt; \"AcquisitionAnalysisManager\":\n    \"\"\"Save the figure as a file.\n\n    Args:\n        fig (Figure, optional): Figure that should be saved. Figure could be any class with\n         function save_fig implemented. By default gets plt.gcf().\n        name (str, optional): Name of the fig. It's a suffix that will be added to the filename.\n            Defaults to None.\n        extensions(str, optional): Extensions of the file. Defaults to `pdf`.\n        tight_layout(bool, optional): True to call fig.tight_layout(). Defaults to True.\n\n    Raises:\n        ValueError: if analysis_data is not loaded\n\n    Return:\n        self\n    \"\"\"\n    self.data.save_fig(fig=fig, name=name, extensions=extensions, **kwds)\n    return self\n</code></pre>"},{"location":"code/acquisition_notebook_manager/#labmate.acquisition_notebook.acquisition_analysis_manager.AcquisitionAnalysisManager.set_config_file","title":"set_config_file","text":"<pre><code>set_config_file(filename)\n</code></pre> <p>Set self.config_file to filename. Verify if exists. Only set config file for future acquisition and will not change current acquisition</p> Source code in <code>labmate/acquisition/acquisition_manager.py</code> <pre><code>def set_config_file(\n    self, filename: Union[str, List[str], Tuple[str, ...]]\n) -&gt; \"AcquisitionManager\":\n    \"\"\"Set self.config_file to filename. Verify if exists.\n    Only set config file for future acquisition and will not change current acquisition\n    \"\"\"\n    if not isinstance(filename, (list, set, tuple)):\n        filename = [str(filename)]\n\n    self.config_files = list(filename)\n    self._config_files_names_to_path = {Path(file).name: file for file in self.config_files}\n\n    for config_file in self.config_files:\n        if not Path(config_file).exists():\n            raise ValueError(f\"Configuration file at {config_file} does not exist\")\n\n    return self\n</code></pre>"},{"location":"code/linting/","title":"Code linting","text":""},{"location":"code/linting/#use-case","title":"Use case","text":""},{"location":"code/linting/#setup","title":"Setup","text":""},{"location":"code/linting/#usage","title":"Usage","text":""},{"location":"code/parsing_config/","title":"Parsing config files","text":""},{"location":"code/parsing_config/#use-case","title":"Use case","text":""},{"location":"code/parsing_config/#setup","title":"Setup","text":""},{"location":"code/parsing_config/#usage","title":"Usage","text":""},{"location":"releases/","title":"Index","text":""},{"location":"releases/#080","title":"0.8.0","text":"<p>October 2023</p>"},{"location":"releases/#070","title":"0.7.0","text":"<p>June 2023</p>"},{"location":"releases/#061","title":"0.6.1","text":"<p>May 2023</p>"},{"location":"releases/#060","title":"0.6.0","text":"<p>May 2023</p>"},{"location":"releases/#050","title":"0.5.0","text":"<p>March 2023</p>"},{"location":"releases/#040","title":"0.4.0","text":"<p>February 2023</p>"},{"location":"releases/0.4.0/","title":"Version 0.4.0. What's new?","text":"<p>Quickly:</p> <ul> <li>Linting error inside analysis_cell!</li> <li>Function to parse your config files</li> <li>New class AttrDict. Classical dictionary accessible by attr</li> </ul>"},{"location":"releases/0.4.0/#parse-config-files","title":"Parse config files","text":"<pre><code>aqm.set_default_config_files(['config1.py', 'config2.py'])\n\naqm.parse_config_str([\"a\", \"b\"]) # -&gt;  'a = 123; b = 123000'\n</code></pre>"},{"location":"releases/0.4.0/#units-and-format","title":"Units and format","text":"<p>It's possible to provide a unit and a format to parse config function. Use the such structure for the string <code>key__unit__format</code>.</p> <p>Examples:</p> <pre><code># from config: k = 123.54321\n\naqm.parse_config_str([\"k__ms__2f\"]) # -&gt; 'k = 123.54 (ms)'\n\naqm.parse_config_str([\"k__ms\"]) # -&gt; 'a = 123.54321 (ms)'\n\naqm.parse_config_str([\"k__2f\"]) # -&gt; 'a = 123.54'\n\naqm.parse_config_str([\"k__2e\"]) # -&gt; 'a = 1.23e+02'\n</code></pre>"},{"location":"releases/0.4.0/#warning-when-analyzing-old-data","title":"Warning when analyzing old data","text":"<p>Now when you're analyzing old files using aqm.analysis_cell inside the Jupyter notebook you will see a warning.</p>"},{"location":"releases/0.4.0/#linting","title":"Linting!","text":"<p>Now analysis cell is parsed in the search for a classical error.</p> <p>It happens a lot that you use by mistake global variables inside analysis_cell, now you can prevent it.</p>"},{"location":"releases/0.4.0/#how-to-setup","title":"How to setup","text":"<p>You can set explicitly which external variables you are allowed to use inside analysis_cell</p> <pre><code>aqm.linting(allowed_variables=['aqm', 'plt'])\n</code></pre> <p>Or you can parse the init_analyse file. (Normally this is a file which is run before running the analysis cell so you are allowed to use any variables from it)</p> <pre><code>aqm.linting(init_file=\"files/init_analyse.py\")\n</code></pre> <p>Note that this function will not look inside if you use import of type <code>from module import *</code></p>"},{"location":"releases/0.4.0/#how-to-use","title":"How to use","text":"<p>After running <code>aqm.linting</code> there is nothing more to do, just run the usual <code>aqm.analysis_cell</code> and see if there are any warnings.</p> <p>If some usage of global variables should be ignored add <code># noqa</code> at the end of the line.</p>"},{"location":"releases/0.4.0/#attrdict","title":"AttrDict","text":"<p>Now there is a new class available: <code>AttrDict</code>. It's a classical dictionary but allows to access it by attributes.</p> <p>Simple example:</p> <pre><code>data = AttrDict({'a': 123})\nprint(data.a) # -&gt; 123\n</code></pre> <p>Recursive example:</p> <pre><code>data = AttrDict({'a':{'b': 456}})\nprint(data.a.b) # -&gt; 456\n</code></pre> <p>Feature: Now parsed data from the config files are returned as an instance of <code>AttrDict</code>, so it can be easily accessed.</p>"},{"location":"releases/0.4.0/#minor-features","title":"Minor features","text":"<ul> <li>SyncData.asdict() -&gt; dict</li> <li>more tests</li> </ul>"},{"location":"releases/0.5.0/","title":"Version 0.5.0. What's new?","text":"<p>Quickly:</p> <ul> <li>Linting ignores the variables inside save_acquisition</li> <li>New AcquisitionLoop which saves on edit</li> <li>Possibility to save data with setitem on aqm</li> <li>Possibility to precise inside the analysis_cell the name of the expected acquisition</li> <li>Parse config files more easily</li> <li>Prerun hook, i.e. a function that runs at the beginning of each acquisition or analysis.</li> </ul>"},{"location":"releases/0.5.0/#linting-ignores-the-variables-inside-save_acquisition","title":"Linting ignores the variables inside save_acquisition","text":"<p>The title is explicit, now there is no need to write <code>#noqa</code> at the end of each line of <code>save_acquisition</code>, all variables are ignored automatically.</p>"},{"location":"releases/0.5.0/#new-acquisitionloop-which-saves-on-edit","title":"New AcquisitionLoop which saves on edit","text":"<p>Previously <code>AcquisitionLoop</code> did not support saving on edit, or to be more precise, it saved everything every time something changed. This is not normal, so this module has been rewritten and now only saves the part that has been changed.</p> <p>Usage is the same:</p> <pre><code>aqm['loop'] = loop = AcquisitionLoop()\nfor i in loop.iter(10):\n    loop.append(x=i**2)\naqm.save_acquisition()\n</code></pre> <p>Or the same thing in the more short way:</p> <pre><code>aqm['loop'] = loop = AcquisitionLoop()\nfor i in loop(10):\n    loop(x=i**2)\naqm.save_acquisition()\n</code></pre> <p>Note: In case of any bugs, the old AcquisitionLoop is still available using <code>AcquisitionLoopOld</code> class. But if there's any problem open an issue, please.</p>"},{"location":"releases/0.5.0/#possibility-to-save-data-with-setitem-on-aqm","title":"Possibility to save data with setitem on aqm","text":"<p>Now it's possible to save data as:</p> <pre><code>aqm['loop'] = AcquisitionLoop()\n</code></pre> <p>Instead of this:</p> <pre><code>aqm.aq['loop'] = AcquisitionLoop()\n</code></pre> <p>Note:</p> <ul> <li>This function is only available inside <code>acquisition_cell</code> and not <code>analysis_cell</code>. Inside an analysis_cell use <code>aqm.d['key']=value</code> to save something.</li> <li>It's only possible to save data and not get it. To get data use <code>aqm.d['key']</code> inside <code>analysis_cell</code> or <code>aqm.aq['key']</code> inside <code>acquisition_cell</code>.</li> </ul>"},{"location":"releases/0.5.0/#possibility-to-precise-inside-the-analysis_cell-the-name-of-the-expected-acquisition","title":"Possibility to precise inside the analysis_cell the name of the expected acquisition","text":"<p>Sometimes you have to double-check that you don't start the wrong analysis. Now it's possible to specify inside an analysis_cell which acquisition_cell it should follow.</p> <p>Suppose an acquisition cell is:</p> <pre><code>aqm.acquisition_cell(\"measure_1\")\n...\n</code></pre> <p>Then, inside an analysis cell:</p> <pre><code>aqm.analysis_cell(acquisition_name = \"measure_1\")\n...\n</code></pre> <p>It's also possible to use regex syntax: (note: string should start with <code>^</code>)</p> <pre><code>aqm.analysis_cell(acquisition_name = r\"^measure_\\d\")\n...\n</code></pre>"},{"location":"releases/0.5.0/#parse-config-files-more-easily","title":"Parse config files more easily","text":"<p>From v0.4.0 it was possible to do something like this to output the values:</p> <pre><code>aqm.parse_config_str([\"a\", \"b\"]) # -&gt; 'a = 123; b = 123000'\n</code></pre> <p>But what if you needed to get the actual value? The solution before was:</p> <pre><code>aqm.set_default_config_files(['config1.py', 'config2.py'])\ndata = aqm.parse_config()\ndata['x'] # -&gt; 123\ndata.b # -&gt; 123\n</code></pre> <p>Now you can do:</p> <pre><code>aqm.set_default_config_files(['config1.py', 'config2.py'])\naqm.cfg['x'] # -&gt; 123\naqm.cfg.b # -&gt; 123000\n</code></pre> <p>Note: values inside the config files are calculated once and then cached to make access quicker. Therefore, you should not modify them.</p>"},{"location":"releases/0.5.0/#prerun-hook","title":"Prerun hook","text":"<p>If you have a default function that should be run before each acquisition or analysis, it's possible to provide it as a hook.</p> <p>First, define the function:</p> <pre><code>def check_instruments():\n    ...\n</code></pre> <p>Then inside the acquisition cell give this function as an argument:</p> <pre><code>aqm.acquisition_cell('measure_1', prerun=check_instruments)\n...\n</code></pre> <p>It is also possible to pass a default function for all acquisition cells:</p> <pre><code>aqm.set_acquisition_cell_prerun_hook(check_instruments)\n</code></pre> <p>Note:</p> <ul> <li> <p>It's possible to provide a list of functions or do a mix between default functions and locally given ones.</p> </li> <li> <p>The same possibility exists for <code>analysis_cell</code>. Use <code>prerun</code> as a keyword or <code>set_analysis_cell_prerun_hook</code> for the global definition.</p> </li> </ul>"},{"location":"releases/0.5.0/#minor-features","title":"Minor features","text":"<ul> <li>tight_layout is run by default before saving the figure.</li> <li>Almost everything is tested so hope a number of the errors will converge to zero. Coverage report: 96%.</li> </ul>"},{"location":"releases/0.6.0/","title":"Version 0.6.0. What's new?","text":"<p>Quickly:</p> <ul> <li>You can access the filename inside <code>parse_config_str</code> function</li> <li>Smarter config parsing. Now you can save the values used during acquisition.</li> <li><code>cfg</code> is now an attribute of <code>aqm.data</code> object.</li> <li>Linting works with the local function definition.</li> <li>Add json utils</li> <li>class Path have more functionality</li> </ul>"},{"location":"releases/0.6.0/#you-can-access-the-filename-inside-parse_config_str-function","title":"You can access the filename inside <code>parse_config_str</code> function","text":"<p>As easy as it sounds all these syntaxes are possible:</p> <pre><code>aqm.parse_config_str(['filename']) # -&gt; \"filename = ...\"\n\naqm.parse_config_str(['file']) # -&gt; \"file = ...\"\n\naqm.parse_config_str(['f']) # -&gt; \"f = ...\"\n</code></pre>"},{"location":"releases/0.6.0/#cfg-is-now-an-attribute-of-aqmdata-object","title":"<code>cfg</code> is now an attribute of <code>aqm.data</code> object.","text":"<p>With version 0.5.0 possibility to parse default configurations was added. The syntax is like this:</p> <pre><code>aqm.set_default_config_files(['config1.py', ...])\n...\naqm.analysis_cell()\naqm.cfg.b # Wrong way to access the configuration value\n</code></pre> <p>But to make it more explicit that the configurations which have been parsed is the ones saved during acquisition, the best practice is to use <code>aqm.data.cfg</code> instead.</p> <pre><code>aqm.set_default_config_files(['config1.py', ...])\n...\naqm.analysis_cell()\naqm.data.cfg.b # Right way\n</code></pre> <p>Keep in mind that in future updates the syntax <code>aqm.cfg</code> could be suspended.</p>"},{"location":"releases/0.6.0/#smarter-config-parsing-now-you-can-save-the-values-used-during-acquisition","title":"Smarter config parsing. Now you can save the values used during acquisition.","text":"<p>More on parsing the configurations files. Some configuration files are like this:</p> <pre><code>def local_switch(param):\n    if param == 'a':\n        return 'param_a'\n    return 'param_b'\n\nstr_1 = \"a\"\nstr_2 = local_switch(str_1)\n</code></pre> <p>And it's evident that str_2 is equal to \"param_b\". We still don't want to eval the config file during analysis just to find out what the values are. But you imported the config file during the acquisition, so why not save the values that were used? And this is exactly the logic of the following function.</p> <p>Suppose you have the configuration file named <code>config.py</code> with the code given just above. Inside your main script you <code>import config as some_cfg</code>. Then, you should give this module to aqm:</p> <pre><code>aqm.set_config_file([\"files/config.py\"])\naqm.set_config_evaluation_module(\"files/config.py\", some_cfg)\n</code></pre> <p>Remember that the name of the config files should be unique even if there are in different folders.</p> <p>Then inside your analysis_cell you can parse <code>str_2</code> parameter.</p> <pre><code>aqm.analysis_cell()\n\naqm.data.parse_config_str(['str_1', 'str_2'])\n# -&gt; 'str_1 = a; str_2 = param_a'\n</code></pre>"},{"location":"releases/0.6.0/#linting-works-with-the-local-function-definition","title":"Linting works with the local function definition.","text":"<p>Now the linting works with the local function definition, but not completely ignores it. It will ignore all the local variables inside your function, but will lint the global ones.</p>"},{"location":"releases/0.6.0/#example","title":"Example:","text":"<pre><code>aqm.analysis_cell()\ndef abc(a, b):\n    c = a + b\n    return c * x\n</code></pre> <p>This code will lint only <code>x</code> variable.</p>"},{"location":"releases/0.6.0/#add-json-utils","title":"Add json utils","text":"<p>Problems with classical json that are solved:</p> <ul> <li>When loading, int and float values are strings. So <code>read</code> function uses <code>NumbersDecoder</code> by default.</li> <li>When dumping, object that can be converted to string or list are not converted. So <code>write</code> function converts objects to string and iterable to list.</li> </ul>"},{"location":"releases/0.6.0/#example_1","title":"Example:","text":"<pre><code>from labmate import json as jsn\ndata = {'a': 1}\njsn.write(path, data)\n</code></pre> <pre><code>from labmate import json as jsn\ndata = jsn.read(path)\n</code></pre>"},{"location":"releases/0.6.0/#better-path-class","title":"Better Path class","text":"<p>Class Path is improvement of class Path from standard pathlib library. And now it's even better.</p>"},{"location":"releases/0.6.0/#features-of-path-class","title":"Features of Path class:","text":"<ul> <li><code>makedirs</code>. Same as os.makedirs(dirname(path)).</li> <li><code>make_extension</code>. Checks is extension of the file is the one (or ones) expected. Otherwise add suffix to the end of the path.</li> </ul>"},{"location":"releases/0.6.0/#useful-properties","title":"Useful properties:","text":"<ul> <li><code>dirname</code></li> <li><code>basename</code></li> </ul> <p>Both return object of type Path.</p>"},{"location":"releases/0.6.0/#minor-features","title":"Minor features","text":"<ul> <li>Fix bugs with <code>AcquisitionLoop</code></li> <li>Fix the bug at detecting an error in a last acquisition_cell run</li> <li>Remove all <code>from __future__ import annotations</code></li> <li>Ignore bool type during config evaluation</li> </ul>"},{"location":"releases/0.6.1/","title":"Version 0.6.1. What's new?","text":"<p>This is a minor update for important features.</p>"},{"location":"releases/0.6.1/#features-added","title":"Features added:","text":"<ul> <li>Short way to call enumerate(loop(...)) -&gt; loop.enum(...)</li> <li>List of str and object can also be saved. It's saved as json string.</li> </ul>"},{"location":"releases/0.6.1/#minor-features","title":"Minor features","text":"<ul> <li>Fix saving complex numbers inside AcquisitionLoop</li> </ul>"},{"location":"releases/0.7.0/","title":"Version 0.7.0. What's new?","text":""},{"location":"releases/0.7.0/#quickly","title":"Quickly:","text":"<ul> <li>Cleaner usage of <code>aqm</code>. Save and load more than one file.</li> <li>List of str and object can also be saved.</li> <li>Saved config files can be imported. Parsing of multiline values.</li> <li>Functions can be saved.</li> <li><code>ConfigFile</code> has find and output methods.</li> <li>Short way to call enumerate(loop(...)) -&gt; loop.enum(...).</li> <li>Figures can again be saved inside h5 file.</li> </ul>"},{"location":"releases/0.7.0/#cleaner-usage-of-aqm-save-and-load-more-than-one-file","title":"Cleaner usage of <code>aqm</code>. Save and load more than one file.","text":""},{"location":"releases/0.7.0/#cleaner-usage-of-aqm","title":"Cleaner usage of <code>aqm</code>.","text":"<p>Now it's easy to create and analyze data outside of acquisition_cell and analysis_cell Load file:</p> <pre><code>data = aqm.load_file(\"2023_01_31__12_34_56__simple_sine\")\n\ntype(data) # -&gt; 'AnalysisData'\n</code></pre> <p>Create a new file:</p> <pre><code>aq = aqm.create_acquisition('list_item')\naq['x'] = 123\naq.save_acquisition(y=456)\n</code></pre>"},{"location":"releases/0.7.0/#save-and-load-more-than-one-file","title":"Save and load more than one file.","text":"<p>Acquisition cell:</p> <pre><code>aqm.acquisition_cell('list')\nfiles = []\nfor i in range(5):\n    aq = aqm.create_acquisition('list_item')\n    x, y = take_some_data(param=i)\n    aq.save_acquisition(\n        x=x, y=y,\n        func_code=take_some_data, # keep track of the function you used\n        parent=aqm.current_filepath.str) # optional, but good to keep a trace of the files\n\n    files.append(aq.filepath)\n    aqm['files'] = files\n\naqm.save_acquisition() # optional, but good practice\n</code></pre> <p>Analysis cell</p> <pre><code>aqm.analysis_cell(acquisition_name=r\"^list\")\nfor file in aqm.data.files:\n    data = aqm.load_file(file)\n    data.x, data.y\n</code></pre>"},{"location":"releases/0.7.0/#list-of-str-and-object-can-also-be-saved","title":"List of str and object can also be saved","text":"<p>Any list that can be converted to json can be saved now. Examples:</p> <pre><code>['a', 'b', 'c']\n['a', 'b', {'p1': 'c', 'p2': 'd'}]\n['a', 'b', [1, 2, 3]]\n</code></pre>"},{"location":"releases/0.7.0/#saved-config-files-can-be-imported","title":"Saved config files can be imported.","text":"<p>If you need to import a module that you have saved as a string inside the file, you can do so.</p> <p>While the use of the eval function can be debatable, it is still very explicit.</p> <p>Example of a config file <code>config1.py</code></p> <pre><code>def abc(a):\n    return 3*a\nparam1 = 123\n</code></pre> <p>Saving:</p> <pre><code>aqm.set_default_config_files([\"config1.py\"]) # run ones on aqm initialization\n</code></pre> <p>Reading:</p> <pre><code>cfg = aqm.data.parse_config_file('config1.py')\n\ncfg.param1 # -&gt; 123  # file is parsed by default without being evaluated\n\ncfg_module = cfg.eval_as_module()\n\n# now cfg_module works as if you imported config1.py\ncfg_module.abc(2) # -&gt; 4\ncfg_module.param1 # -&gt; 123\n</code></pre>"},{"location":"releases/0.7.0/#multiline-parsing","title":"Multiline parsing","text":"<p>Values that are written in multiple lines inside config files are now parsed. But still, there are not evaluated, so if you saved a dictionary it will be a string when parsed. To convert a string to a dictionary you can use <code>eval_key</code> method that evaluates the string.</p> <pre><code>aqm.data.parse_config_file('config1.py').eval_key('param1')\n</code></pre>"},{"location":"releases/0.7.0/#functions-can-be-saved","title":"Functions can be saved","text":"<p>It's possible to save a simple function now.</p> <pre><code>aqm.acquisition_cell('simple_sine')\n\ndef acquire_data(size):\n    import numpy as np\n    x = np.linspace(0, 10*np.pi, size)\n    y = np.sin(x)\n    return x, y\n\naqm.save_acquisition(acquire_data=acquire_data);\n</code></pre> <pre><code>aqm.analysis_cell(acquisition_name=r\"^simple_\\w\")\naqm.d.acquire_data.code # return code of the function\n\naqm.d.acquire_data.eval(101) # evaluate the function with given args and kwds\n</code></pre> <p>Functions are saved as a string inside the h5 file and are evaluated on the first eval method call. Not when the file is loaded. Therefore, use of eval function is still explicit.</p>"},{"location":"releases/0.7.0/#configfile-has-find-and-output-methods","title":"ConfigFile has find and output methods","text":"<p><code>ConfigFile</code>(subclass of an <code>AttrDict</code>) is a class used when a config file is loaded. It's a classical dict, but with possibility to access items as attributes.</p> <p>Now you can find items inside dict and output values.</p>"},{"location":"releases/0.7.0/#find","title":"Find","text":"<pre><code>data =  AttrDict({'param_1': 'value1', 'param_2': 'value2'})\ndata.find('param') # -&gt; ('param_1', 'value1')\ndata.find_all('param') # -&gt; [('param_1', 'value1'), ('param_2', 'value2')]\n</code></pre>"},{"location":"releases/0.7.0/#output","title":"Output","text":"<p>The syntax is the same as <code>parse_config_str</code> function.</p> <pre><code>data =  AttrDict({'param_1': 123.43})\n\ndata.output([\"param_1\"]) # -&gt; param_1 = 123.43\ndata.output([\"param_1__m/s__1f\"]) # -&gt; param_1 = 123.4 (m/s)\n</code></pre>"},{"location":"releases/0.7.0/#short-way-to-call-enumerateloop-loopenum","title":"Short way to call enumerate(loop(...)) -&gt; loop.enum(...)","text":"<p>As easy as the title says. No need to call enumerate on loop just use <code>loop.enum(...)</code></p> <pre><code>aqm.acquisition_cell('simple_sine')\n\naqm['some_loop'] = loop = AcquisitionLoop()\n\nfor i, q in loop.enum(1, 5, .5):\n    loop.append(x=i, y=q)\n</code></pre> <pre><code>aqm.analysis_cell(acquisition_name=r\"^simple_\\w\")\naqm.d.some_loop.x  # -&gt; [0., 1., 2., 3.]\naqm.d.some_loop.y  # -&gt; [1. , 1.5, 2. , 2.5]\n</code></pre>"},{"location":"releases/0.7.0/#figures-can-again-be-saved-inside-h5-file","title":"Figures can again be saved inside h5 file.","text":"<p>Before, figures were saved with pickle library. But then figures cannot be opened on different systems. So a new library <code>pltsave</code> was used. This allows to save and open the figure on different systems.</p>"},{"location":"releases/0.7.0/#usage-as-before","title":"Usage (as before):","text":"<p>To save a particular figure use <code>inside_h5</code> keyword:</p> <pre><code>aqm.save_fig(fig, inside_h5=True)\n</code></pre> <p>To save every figure, set <code>save_fig_inside_h5</code> keyword during init of <code>AcquisitionAnalysisManager</code> to True:</p> <pre><code>aqm = AcquisitionAnalysisManager(..., save_fig_inside_h5=True)\n</code></pre>"},{"location":"releases/0.7.0/#minor-features","title":"Minor features","text":"<ul> <li>Fix saving complex numbers inside AcquisitionLoop</li> </ul>"},{"location":"releases/0.8.0/","title":"Version 0.8.0. What's new?","text":""},{"location":"releases/0.8.0/#quickly","title":"Quickly:","text":"<ul> <li>Documentation is available!</li> </ul>"},{"location":"starting_guide/advanced_examples/","title":"Advanced example","text":""},{"location":"starting_guide/advanced_examples/#mode-understanding","title":"Mode understanding","text":"<p>Modes can be set by providing <code>mode=..</code> keyword or explicitly by specifying <code>read_only</code> and <code>overwrite</code> options.</p> <p>'w' mode is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=False)\n</code></pre> <p>'a' mode is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=False, overwrite=False)\n</code></pre> <p>'r' mode is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=True)\n</code></pre> <p>DH5.open_overwrite method is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=False, overwrite=True)\nor\n&gt;&gt;&gt; sd = DH5('somedata.h5', mode='w', overwrite=True)\n</code></pre>"},{"location":"starting_guide/advanced_examples/#mirroring-acquisitions-with-a-custom-backend","title":"Mirroring acquisitions with a custom backend","text":"<p><code>AcquisitionManager</code> accepts an optional <code>AcquisitionBackend</code> implementation. Backends run in the background every time an acquisition is saved and can be used to duplicate the generated HDF5 file (and the companion Python/configuration files that Labmate writes next to it) to another location.</p> <p>The example below mirrors every saved acquisition into a second directory. It does so by copying the HDF5 file and any file that shares the same stem (e.g. <code>*_CELL.py</code>, copied configuration files, \u2026) to the mirror folder.</p> <pre><code>from pathlib import Path\nimport shutil\n\nfrom labmate.acquisition import AcquisitionBackend\nfrom labmate.acquisition_notebook import AcquisitionAnalysisManager\n\n\nclass MirrorDirectoryBackend(AcquisitionBackend):\n    def __init__(self, mirror_root: str):\n        self._mirror_root = Path(mirror_root)\n\n    def save_snapshot(self, acquisition):\n        source_prefix = Path(acquisition.filepath)\n        destination_dir = self._mirror_root / source_prefix.parent.name\n        destination_dir.mkdir(parents=True, exist_ok=True)\n\n        # Copy the main HDF5 file and any auxiliary files generated by Labmate.\n        for source_path in source_prefix.parent.glob(f\"{source_prefix.name}*\"):\n            shutil.copy2(source_path, destination_dir / source_path.name)\n\n\nbackend = MirrorDirectoryBackend(\"/mnt/labmate-mirror\")\naqm = AcquisitionAnalysisManager(\"/data/labmate\", backend=backend)\n</code></pre> <p>When <code>save_acquisition</code> (or <code>save_acquisition</code> on <code>AcquisitionAnalysisManager</code>) is called, Labmate will asynchronously copy the freshly written files to the mirror directory. Should you need to hydrate new local acquisitions from an existing mirror, implement <code>load_snapshot</code> in the same backend and perform the copy in the opposite direction.</p>"},{"location":"starting_guide/first_steps/","title":"Getting Started with Labmate","text":"<p>Make sure you have installed the package before.</p>"},{"location":"starting_guide/first_steps/#overview","title":"Overview","text":"<p>Easily we can divide classical scientific experiment to acquisition of some data and analysis of this data. An acquisition is something that is run ones to get nice data and then you'd like to analyze it. <code>Labmate</code> library also separates these two stage and protects the data during an analysis by using read-only access to the data.</p> <p>During this tutorial we start with the simple experimental sequence, and then see which features <code>labmate</code> to improve you experience and assure the further reuse of your data.</p>"},{"location":"starting_guide/first_steps/#simple-example","title":"Simple example","text":"<p>As mentioned above every experimental sequence consists of 2 steps: acquisition and analysis.</p>"},{"location":"starting_guide/first_steps/#setup","title":"Setup","text":"<p>Before starting performing the experiment you should defined AcquisitionAnalysisManager. It's super simple: you import it and give it an directory where to save your data.</p> <pre><code>from labmate.acquisition_notebook import AcquisitionAnalysisManager\n\naqm = AcquisitionAnalysisManager(\"tmp_data\")\n# this would save data inside /path/to/current/file/tmp_data/\n</code></pre>"},{"location":"starting_guide/first_steps/#acquisition-cell","title":"Acquisition cell","text":"<p>Acquisition cell is a notebook cell that performs the experiment and saves the results. It should start with <code>acquisition_cell</code> method.</p> <pre><code>aqm.acquisition_cell('test_example')\n\n# acquire data. Here is an example of simple sinusoidal data.\nx = np.linspace(0, 20*np.pi, 101)\nyour_data = np.sin(x)\n\n# Save data to the file.\naqm.save_acquisition(x=x, y=your_data)\n</code></pre>"},{"location":"starting_guide/first_steps/#analysis-data","title":"Analysis data","text":"<p>Analyze of data starts by <code>analysis_cell</code>. During your analysis, you should never uses variable outside of your saved date. To assure this, you should access variables via <code>aqm.data</code>.</p> <pre><code>aqm.analysis_cell()\n\nfig = plt.figure()\nplt.plot(aqm.data.x, aqm.data.y)\naqm.save_fig(fig)\n</code></pre>"},{"location":"starting_guide/first_steps/#further-details","title":"Further Details","text":"<p>To learn even more about how dh5 is structured, explore the Advanced Examples.</p>"},{"location":"starting_guide/install/","title":"Installation labmate","text":"<p>You can install the <code>Labmate</code> library using either pip or by pulling the repository directly from GitHub.</p>"},{"location":"starting_guide/install/#option-1-install-via-pip","title":"Option 1: Install via Pip","text":"<p>Open your terminal and run the following command</p> <pre><code>pip install lambate\n</code></pre>"},{"location":"starting_guide/install/#option-2-install-from-github","title":"Option 2: Install from GitHub","text":"<p>You can also install <code>Labmate</code> directly from its GitHub repository. This option is useful if you want to work with the latest development version or if you need to customize the library. Here's how to do it:</p> <ol> <li>Clone the <code>labmate</code> repository from GitHub using the following command:</li> </ol> <pre><code>git clone https://github.com/kyrylo-gr/labmate.git\n</code></pre> <ol> <li>Enter the directory and install the package.</li> </ol> <pre><code>cd labmate\npip install .\n</code></pre> <p>Instead <code>pip install .</code> you can run <code>python setup.py develop</code> if you prefer.</p>"},{"location":"starting_guide/install/#thats-it","title":"That's it!","text":"<p>You've successfully installed the <code>Labmate</code> library. You can now start incorporating <code>Labmate</code> into your Python projects.</p> <p>For further insight, please refer to the First Steps guide.</p>"}]}